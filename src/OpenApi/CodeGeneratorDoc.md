# Code Generator doc

Created: August 9, 2022 10:23 AM
Last Edited Time: August 10, 2022 10:30 AM

# Overview üñ•Ô∏è

This is a CLI tool that generates the server side API route handler code in Minimal API from an Open API spec.

Some possible use cases for this tool are testing and validating API contracts, including mocking for a single service and performing UI integration tests with the generated mock server. This tool can also be used to facilitate decoupled development.

# How to use the tool üî®

In order for the tool to work, there are a couple of steps we must take to properly set up the environment. 

We must create the `MinimalApiTemplate.cs` file which will be created in design time by the `[MinimalApiTemplate.tt](http://MinimalApiTemplate.tt)` file. In order to do this:

1. Open the `OpenApi.sln` file on VS. 
2. Right click on the `[MinimalApiTemplate.tt](http://MinimalApiTemplate.tt)` and select `Properties` .
3. Change the `Build Action` property to `Content` and the `Custom Tool` property to `TextTemplatingFilePreprocessor` .
4. After doing this you should be able to right click the `[MinimalApiTemplate.tt](http://MinimalApiTemplate.tt)` file and select `Run Custom Tool` .
5. This will generate the `MinimalApiTemplate.cs` file which will be responsible for writing the code to the output file.

At this point, the tool is ready for use, and can be executed with the following command:

`dotnet run <open_api_spec_path> <output_file_path>`

### Arguments

`<open_api_spec_path>` corresponds to the file path of the json file containing the Open API documentation.

`<output_file_path>` is the path where the output file will be created. 

## Constraints

`<open_api_spec_path>` has to be a valid path to .json file.

`<output_file_path>` has to be a valid path to .cs file. If a file path for an existing file is passed, the existing file will be overwritten. 

# Implementation ‚öôÔ∏è

## Logic

Inside of the `CodeGenerator.cs` file, the `OpenApi.Reader` package is used to read the Open Api spec into an `OpenApiDocument` .

Then , parse the properties of `OpenApiDocument` (paths, HTTP methods, arguments, schemas, etc) into two dictionaries- `fileProperties` and `schemaDict` . 

Both of these dictionaries are passed onto `[MinimalApiTemplate.tt](http://MinimalApiTemplate.tt)` , which is the T4 template with the code generation pattern. 

The T4 template iterates through the dictionaries and uses the values to write the code pattern for the route handlers. The `MinimalApiTemplate.cs` file generated by 

the T4 template during design time contains the method `TranformText()` that is used to produce the output code as a string value.

## Dependencies

- Microsoft.OpenApi (1.3.2)
- Microsoft.OpenApi.Reader (1.3.2)
- System.CodeDom (6.0.0)
- Microsoft.VisualStudio.TextTemplating.15.0

# Sample

## Input

```json
"openapi": "3.0.2",
  "info": {
    "title": "Swagger Petstore - OpenAPI 3.0",
    "description": "This is a sample server",
    "version": "1.0.11"
  },
  "externalDocs": {
    "description": "Find out more about Swagger",
    "url": "http://swagger.io"
  },
  "servers": [
    {
      "url": "/api/v3"
    }
  ],
  "tags": [
    {
      "name": "pet",
      "description": "Everything about your Pets",
      "externalDocs": {
        "description": "Find out more",
        "url": "http://swagger.io"
      }
    },
    {
      "name": "store",
      "description": "Access to Petstore orders",
      "externalDocs": {
        "description": "Find out more about our store",
        "url": "http://swagger.io"
      }
    },
    {
      "name": "user",
      "description": "Operations about user"
    }
  ],
  "paths": {
    "/": {
      "get": {
        "tags": [
          "store"
        ],
        "summary": "Welcome message",
        "description": "Write the welcome message",
        "operationId": "welcomeUser",
        "responses": {
          "200": {
            "description": "Successful operation",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                },
                "example": "Welcome to the store!"
              }
            }
          }
        }
      }
    },
    "/pet": {
      "put": {
        "tags": [
          "pet"
        ],
        "summary": "Update an existing pet",
        "description": "Update an existing pet by Id",
        "operationId": "updatePet",
        "requestBody": {
          "description": "Update an existent pet in the store",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Pet"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Pet"
                },
                "example": {
                  "id": 56,
                  "name": "Max",
                  "category": {
                    "id": 56,
                    "name": "Max"
                  },
                  "photoUrls": [
                    "http://samplelink.com/image1",
                    "http://samplelink.com/image2"
                  ],
                  "tags": null,
                  "status": "available"
                }
              }
            }
          },
          "400": {
            "description": "Invalid ID supplied"
          },
          "404": {
            "description": "Pet not found"
          },
          "405": {
            "description": "Validation exception"
          }
        },
        "security": [
          {
            "petstore_auth": [
              "write:pets",
              "read:pets"
            ]
          }
        ]
      }
```

## Output

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", (HttpContext context) =>
{
    if (context.Request.Headers["AcceptStatusCode"] == "200")
    {
        return Results.Ok("Welcome to the store!");
    }

    return null;
});

app.MapPut("/pet", (HttpContext context) =>
{
    if (context.Request.Headers["AcceptStatusCode"] == "200")
    {
        return Results.Ok(new Pet(56, "Max", new Category(56, "Max"), new [] {"http://samplelink.com/image1", "http://samplelink.com/image2"}, null, "available"));
    }

    if (context.Request.Headers["AcceptStatusCode"] == "400")
    {
        return Results.BadRequest();
    }

    if (context.Request.Headers["AcceptStatusCode"] == "404")
    {
        return Results.NotFound();
    }

    if (context.Request.Headers["AcceptStatusCode"] == "405")
    {
        return Results.StatusCode(405);
    }

    return null;
});
```

# Additional Notes üìí
